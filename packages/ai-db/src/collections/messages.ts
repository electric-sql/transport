/**
 * Messages collection - derived livequery with optimistic mutations.
 *
 * Materializes UIMessage objects by grouping stream rows by messageId.
 * Supports optimistic insert for user messages.
 */

import type {
  Collection,
  LiveQueryCollectionConfig,
  StandardSchemaV1,
} from '@tanstack/db'
import type {
  StreamRowWithOffset,
  MessageRow,
  DurableMessagesConfig,
  ActorType,
} from '../types'
import { materializeMessage, extractTextContent } from '../materialize'

/**
 * Wait for a key to appear in a collection's synced data.
 *
 * @param collection - Collection to wait on
 * @param key - Key to wait for
 * @param timeout - Timeout in milliseconds
 * @returns Promise that resolves when key appears
 */
export function waitForKey<T>(
  collection: Collection<T, string>,
  key: string,
  timeout = 30000
): Promise<void> {
  return new Promise((resolve, reject) => {
    // Check if already present (race condition guard)
    if (collection.has(key)) {
      resolve()
      return
    }

    const timer = setTimeout(() => {
      subscription.unsubscribe()
      reject(new Error(`Timeout waiting for key ${key}`))
    }, timeout)

    const subscription = collection.subscribeChanges((changes) => {
      const found = changes.some(
        (c) => c.type === 'insert' && collection.getKeyFromItem(c.value) === key
      )
      if (found || collection.has(key)) {
        clearTimeout(timer)
        subscription.unsubscribe()
        resolve()
      }
    })
  })
}

/**
 * Creates collection config for the messages collection.
 *
 * This is a derived livequery collection that:
 * 1. Queries: Materializes MessageRow objects by grouping stream rows by messageId
 * 2. Mutates: Has onInsert handlers for optimistic user message insertion
 *
 * The client generates messageId locally (UUID) before posting to proxy.
 * This enables immediate optimistic insertion while tracking sync confirmation.
 *
 * @example
 * ```typescript
 * import { createMessagesCollectionOptions } from '@electric-sql/ai-db'
 * import { createCollection } from '@tanstack/db'
 *
 * const messagesCollection = createCollection(
 *   createMessagesCollectionOptions({
 *     sessionId: 'my-session',
 *     proxyUrl: 'http://localhost:4000',
 *     actorId: 'user-123',
 *     actorType: 'user',
 *     streamCollection,
 *   })
 * )
 * ```
 */
export function createMessagesCollectionOptions(
  config: DurableMessagesConfig
): LiveQueryCollectionConfig<MessageRow> {
  const { sessionId, proxyUrl, actorId, actorType, streamCollection, schema } = config

  return {
    id: `session-messages:${sessionId}`,
    schema,
    getKey: (msg) => msg.id,

    // Derived via livequery - TanStack DB handles subscription and incremental updates
    query: (q) =>
      q
        .from({ row: streamCollection })
        .groupBy(({ row }) => row.messageId)
        .fn.select(({ rows }) => materializeMessage(rows as StreamRowWithOffset[])),

    // Mutation handler: Post to proxy, wait for sync
    onInsert: async ({ transaction, collection }) => {
      for (const mutation of transaction.mutations) {
        const message = mutation.modified

        // Post to proxy (messageId was generated by client)
        const response = await fetch(
          `${proxyUrl}/v1/sessions/${sessionId}/messages`,
          {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              messageId: message.id, // Client-generated messageId
              content: extractTextContent(message),
              actorId: actorId,
              actorType: actorType,
            }),
          }
        )

        if (!response.ok) {
          const errorText = await response.text()
          throw new Error(`Failed to send message: ${response.status} ${errorText}`)
        }

        // Wait for messageId to appear via the query pipeline
        // When this resolves, synced data contains the message
        // TanStack DB then drops optimistic state - no flicker
        await waitForKey(collection, message.id)
      }
    },
  }
}

/**
 * Create a new user message object for insertion.
 *
 * @param content - Text content of the message
 * @param actorId - Actor identifier
 * @param actorType - Actor type
 * @returns MessageRow ready for insertion
 */
export function createUserMessage(
  content: string,
  actorId: string,
  actorType: ActorType = 'user'
): MessageRow {
  const messageId = crypto.randomUUID()

  return {
    id: messageId,
    role: 'user',
    parts: [{ type: 'text', text: content }],
    actorId,
    actorType,
    isComplete: true,
    startOffset: '', // Will be filled by sync
    endOffset: null,
    createdAt: new Date(),
  }
}
